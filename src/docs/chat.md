## Entities

To store chat data we have 2 entities: **Conversation** and **Message**.
![chat database schema](https://i.imgur.com/eAJKR32.png)

Conversation could be only between freelancer and job owner and for each job should be created separate conversation.
[WebSocketGateway by Nest.js](https://docs.nestjs.com/websockets/gateways) was used to implement real time messaging.

You can see it in
```bash
src/modules/chat/chat.gateway.ts
```

## Authentication
[AuthGuard](https://docs.nestjs.com/guards) is used to authorize the user when he try to connect with websocket.
Websocket auth guard:
```bash
src/modules/auth/guards/ws-auth.guard.ts
```

**PassportStrategy** was defined in:
```bash
src/modules/auth/strategies/ws-jwt-strategy.guard.ts
```
This uses a bearer token that is generated by [JWT](https://jwt.io/).
Bearer token must be specified in header of websocket connection.
Example:
```bash
{
    “authorization”: “Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Imt1a3NlcmcxMjNAZ21haWwuY29tIiwiaWF0IjoxNjczMjc0NDE5LCJleHAiOjE2NzQ1NzA0MTl9.zEIchRrJc0t0opSzp2eruLjjS2G8U5iRvX4pGVxNViM”
}
```
You can read more about Nest.js authentication [here](https://docs.nestjs.com/security/authentication)

## Events
**JOIN CONVERSATION**
```bash
src/modules/chat/chat.gateway.ts > ChatGateway > handleJoinConversation
```

event payload example:
```bash
{
    conversation: 1
}
```
Where “conversation” is id of conversation which we want to connect.
This is necessary in order to be able to send messages only to the room we need, and not to all clients (users) connected to the websocket.

**MESSAGE**
```bash
src/modules/chat/chat.gateway.ts > ChatGateway > handleMessage
```

event payload example:
```bash
{
    conversation: 1,
    message: “Hello, world”,
    to: 1,
    job: 1
}
```

- **conversation** – id of conversation
- **message** – text message sent by user
- **to** – id of user who should receive the message
- **job** – id of job

**to** & **job** used for notifications only. We can find this information in the database with a conversation id, but we get this to save server resources and not send an extra request to the database.

You can find information about current user (who sent message) in client.handshake.user
We find out how many users are connected to the room in order to understand whether we need to mark the message as new for the user to whom we send it.

Get it this way, where minRoomsJoins = 2.
```bash
const isUserConnected =
      this.server.sockets.adapter.rooms.get(String(payload.conversation)).size > minRoomJoins;
```
Value of the variable **isUserConnected** tells us if the second user is connected to the room.
if **isUserConnected**  equals “true”. We set “is_read” property as “true” in payload of createMessage method of Chat Service. Otherwise we set it as “false”. The logic is that we don’t need to mark the message as new if the user to whom the message is addressed has opened a chat.
Also if **isUserConnected** is false we need to send a notification. To do this we need call emit method in Notification Service.

**LEAVE CONVERSATION**
```bash
src/modules/chat/chat.gateway.ts > ChatGateway > handleLeaveConversation
```

event payload example:
```bash
{
    conversation: 1
}
```
When user leaves the chat (closes chat page or switches to another chat), client side should emit “leave conversation” event. That’s because we need to send notifications about new messages when the user is not connected to the conversation. Also “is_read” property depends on this.